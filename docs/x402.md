# 0. 문서 목적과 전체 구조

이 자료는 **Base 체인 생태계**에서:

1. **Base App & Mini App**
2. **x402 결제 프로토콜**
3. **Coinbase AgentKit**

이 세 가지가 어떻게 동작하고, 특히 **AI 에이전트 + 온체인 결제**를 어떻게 구현하는지 개략적으로 설명하는 오버뷰 슬라이드다.

---

# 1. Base App & Mini App

## 1.1 Base App (p2)

- 2024년 7월 16일, **Coinbase Wallet → Base App**으로 리브랜딩.
- 목표:

  - **소셜**, **메시징**, **MiniApp**들을 모두 담는 **슈퍼앱(super app)**.
  - 사용자는 이 안에서 다양한 온체인 서비스/앱을 탐색하고 이용.

Base App은 사실상 “Base L2를 위한 지갑 + 소셜 + 미니앱 플랫폼”으로 위치한다.

## 1.2 Mini App 개념 (p3)

- **Mini App** = Base App 또는 Farcaster 클라이언트에서 실행되는 **경량 웹 앱**.
- 특징:

  - 사용자가 별도의 설치 없이 바로 실행.
  - Base App 혹은 Farcaster에서:

    - 검색
    - 소셜 공유
      를 통해 도달 가능.

- 배포 방식:

  - 개발자는 일반 웹앱처럼 **Vercel 등 호스팅 플랫폼**에 배포.
  - Base App이 이 URL을 **Mini App으로 인식 & 인덱싱**하도록 메타데이터 설정.
  - 이 과정을 마치면 Base App 내 검색에서 노출됨.

즉, Mini App은 **PWA에 가까운 웹 앱**이지만, Base 생태계에서 검색/공유/실행이 통합된 형태로 제공된다고 이해하면 된다.

## 1.3 Mini App 개발 시작하기 (p4–5)

- Base 팀이 제공하는 공식 문서와 튜토리얼 비디오가 있음:

  - `Create a new miniapp` 퀵스타트.

- 어떤 문서를 봐야 할지 모를 경우, 문서 사이트가 제공하는 **“Ask AI assistant”** 기능을 통해 질문하면서 필요한 섹션을 찾아갈 수 있다고 설명.

---

# 2. x402: AI·에이전트용 개방형 결제 표준

## 2.1 정의와 핵심 아이디어 (p6–8)

- 정의:

  - **AI 에이전트 및 웹 서비스**가 **API, 데이터, 디지털 서비스**에 대해
    **자율적으로 결제**할 수 있게 하는 **개방형 결제 표준**.

- 핵심 메커니즘:

  - 오래 전부터 예약돼 있던 HTTP 상태 코드 **`402 Payment Required`**를
    실제로 활용하는 프로토콜.

- 주요 이점:

  - **API 키, 구독, 수동 결제 처리 없이**
    **실시간 머신-네이티브 트랜잭션**을 가능하게 한다.

즉, x402는 “HTTP 402 + 온체인 결제 + 스테이블코인”을 조합한 **머신용 결제 레이어**.

## 2.2 왜 필요한가? (동기) (p9–11)

### 2.2.1 자율적 AI 시스템의 병목 (p9)

- AI 및 자율 시스템이 성장하는 데 있어,
  **인간 개입 없이 결제를 수행하는 시스템의 부재**가 큰 장애물.

### 2.2.2 레거시 결제 시스템의 구조적 한계 (p10–11)

- 결제 UX가 **“인간 상호작용” 전제**로 설계됨:

  - 웹폼 탐색
  - 신용카드 번호 입력
  - 계정 생성 및 KYC

- AI 에이전트 입장에선:

  - API 키 관리, 구독 처리, 계정 확정 등 수많은 마찰.

- 비용·속도 문제:

  - 높은 수수료.
  - **은행/카드 정산에 수일** 소요.
  - 차지백(chargeback) 위험.
  - 건당 고정 수수료(예: $0.30) 때문에 **마이크로 결제가 비실용적**.

요약하면: 기존 결제 시스템은 **“에이전트-투-서비스” 환경에 전혀 맞지 않는다.**

## 2.3 블록체인 & 디지털 자산이 제공하는 해법 (p12)

- x402는:

  - **스테이블코인**
  - **Layer-2 확장 (여기서는 Base)**
    를 활용해:
  - 저비용
  - 거의 즉각적인 정산(약 200ms)
  - 차지백 없음
  - **가스비 ~ $0.0001 미만 (사실상 무료급)**
    수준의 결제를 가능하게 한다고 설명.

즉, 온체인 결제의 장점을 적극 활용한다.

## 2.4 프로토콜 개요 & 코어 플로우 (p13–14)

### 2.4.1 4단계 코어 플로우 (p13)

1. **Client Request**

   - 클라이언트(에이전트)가 서버에 일반 HTTP 요청 수행.

2. **402 Payment Required 응답**

   - 서버가 `HTTP 402`를 반환하면서
     가격 및 결제 세부 정보(금액, 수신 지갑, 자산, 네트워크 등)를 포함한 JSON을 보냄.

3. **에이전트가 결제 승인 포함해 재요청**

   - 에이전트가 **EIP-3009 기반 서명된 결제 승인**을 포함해 다시 요청.

4. **서버가 결제 확인 후 응답**

   - 서버(또는 Facilitator)가 결제를 검증/브로드캐스트하고
     최종 리소스를 응답.

### 2.4.2 시퀀스 다이어그램 (p14)

- 페이지 14의 다이어그램은 다음 4개 레인을 보여준다:

  - CLIENT
  - SERVER
  - FACILITATOR
  - BLOCKCHAIN

- 흐름:

  - Client → Server: 요청
  - Server → Client: `402 Payment Required` + x402 payload
  - Client → Facilitator: 결제 명령(서명 포함)
  - Facilitator → Blockchain: 트랜잭션 브로드캐스트
  - Blockchain → Facilitator: 트랜잭션 결과
  - Facilitator → Server: 결제 완료 정보
  - Server → Client: 최종 리소스 응답

즉, 결제는 직접 체인과 상호작용하는 **Facilitator**를 통해 수행된다.

## 2.5 마찰 없는 결제(Onboarding) (p15)

- x402는:

  - 계정 생성
  - KYC
  - API 키 발급/관리
  - 구독 생성/취소
    같은 수동적인 단계를 제거.

- 대신:

  - **AI 에이전트가 “즉시 온보딩”**
  - **스테이블코인 기반 자동 결제**를 수행할 수 있게 함.

## 2.6 새로운 비즈니스 모델: 실용적인 마이크로페이먼트 (p16)

- 요청당/서비스당/사용 초당 과금 등 **정교한 usage-based billing**이 가능.
- 극단적으로 작은 금액 (예: **0.001센트 수준**)까지도 결제할 수 있다고 설명.
- 따라서:

  - 구독/선불 없이도
  - API, AI 추론, 주문형 콘텐츠를
    **요청별 과금(pay-per-request)** 모델로 판매 가능.

- 슬라이드 하단 예시(텍스트+이미지):

  - AI agents accessing APIs
  - Pay-per-use AI models
  - On-demand content
  - Machine-to-machine payments

---

# 3. x402 서버 사이드 스펙

## 3.1 미들웨어 구성 개념 (p17)

- 개발자는 **`paymentMiddleware` (또는 `require_payment`)** 같은 헬퍼를 사용해:

  - **요청당 비용(amount)**
  - **수신 지갑 주소(address)**
    를 한 줄로 설정하여,
  - 해당 엔드포인트를 바로 **유료 API**로 만들 수 있다.

즉, “한 줄 추가 → 이 API는 유료 엔드포인트가 된다”는 개념.

## 3.2 FastAPI(Python) 예시 (p18)

요점만 텍스트 레벨로 정리:

```python
from x402.fastapi.middleware import require_payment

app = FastAPI()

app.middleware("http")(
    require_payment(
        path="/weather",
        price="$0.001",
        pay_to_address="0xAddress",
        network="base-sepolia",
    )
)

@app.get("/weather")
async def get_weather():
    return { "report": { "weather": "sunny", "temperature": 70 } }
```

- 의미:

  - `/weather` 경로로 들어오는 모든 요청에 대해:

    - 가격: `$0.001`
    - 네트워크: `base-sepolia`
    - 수신자: `"0xAddress"`
      조건의 결제가 선행되어야만 실제 응답이 반환된다.

## 3.3 Next.js(JavaScript) 예시 (p19)

핵심 구조:

```ts
import { paymentMiddleware, Network } from "x402-next";

export const middleware = paymentMiddleware(
  "0xYourAddress",
  {
    "/protected": {
      price: "$0.01",
      network: "base-sepolia",
      config: { description: "Access to protected content" },
    },
  },
  {
    url: "https://x402.org/facilitator", // Base Sepolia용 facilitator
  }
);

export const config = {
  matcher: ["/protected/:path*"],
};
```

- 해당 미들웨어는 `/protected` 이하 경로에 대해:

  - `$0.01` 결제가 이뤄져야 요청이 통과된다.

## 3.4 HTTP 402 응답 페이로드 (p20)

- 최초 요청에서 서버는 `HTTP 402`를 반환하며, JSON 안에 다음 필드를 포함:

  - `maxAmountRequired`
  - `payTo`
  - `asset`
  - `network`

- 이 정보는 **에이전트/클라이언트가 결제 세부사항을 이해하고 서명 요청을 구성하는 데** 사용된다.

---

# 4. x402 클라이언트 사이드 스펙

## 4.1 클라이언트 개념 (p21)

- 개발자는 x402 클라이언트 라이브러리를 사용해:

  - 사용자 지갑을 `client.setWallet(wallet)`으로 세팅.
  - `client.fetch` 또는 래핑된 fetch를 사용해 API를 호출.
  - 402 응답을 받으면, 자동으로:

    - 필요한 서명
    - 결제 트랜잭션
      을 수행하고 재요청.

## 4.2 Python: `x402HttpxClient` (p22)

핵심 패턴:

```python
from x402.clients.httpx import x402HttpxClient

# account = 지갑 계정 객체 (EIP-3009 서명 가능)

async with x402HttpxClient(account=account,
                           base_url="https://api.example.com") as client:
    response = await client.get("/protected-endpoint")
    print(await response.aread())
```

- 이 클라이언트는 내부적으로:

  1. `/protected-endpoint` 요청
  2. 402 + x402 payload 수신
  3. 결제 승인 서명 + 재요청
  4. 최종 응답 반환
     과정을 처리한다.

## 4.3 Node.js: `wrapFetchWithPayment` (p23)

핵심 구조:

```ts
import { wrapFetchWithPayment, decodeXPaymentResponse } from "x402-fetch";

// account = 지갑 계정 객체

const fetchWithPayment = wrapFetchWithPayment(fetch, account);

fetchWithPayment(url, { method: "GET" })
  .then(async (response) => {
    const body = await response.json();
    console.log(body);

    const paymentResponse = decodeXPaymentResponse(
      response.headers.get("x-payment-response")!
    );
    console.log(paymentResponse);
  })
  .catch((error) => {
    console.error(error.response?.data?.error);
  });
```

- `wrapFetchWithPayment`는:

  - fetch 요청 중 402 응답이 오면
  - 클라이언트 측에서 결제를 수행하고
  - 다시 fetch를 시도해 최종 응답을 얻는다.

---

# 5. AgentKit: “Every agent deserves a wallet.”

## 5.1 개념 (p24)

- **AgentKit**은:

  - **LLM / 블록체인 네트워크 / 월렛**에 대해 **agnostic**한 설계.
  - 어떤 LLM이든, 어떤 체인이든, 어떤 월렛이든 연결 가능.

- Coinbase Developer Platform(CDP)을 통해:

  - 각 AI 에이전트마다 **고유하고 안전한 블록체인 지갑**을 할당할 수 있다.

즉, AgentKit은 “에이전트에게 온체인 액션 능력(지갑+트랜잭션)을 부여하는 미들웨어/SDK”.

## 5.2 아키텍처: WalletProvider & ActionProvider (p25)

- 두 가지 핵심 인터페이스:

  1. **WalletProvider**

     - 유저 지갑 접근
     - 체인 상의 트랜잭션 서명/송신

  2. **ActionProvider**

     - 온체인/오프체인 액션을 캡슐화한 모듈
     - 예시:

       - `evm_wallet_provider`
       - `erc20_provider`

- 개발자는 다양한 Provider를 조합해:

  - 원하는 기능(토큰 전송, 스왑, 데이터 조회 등)을
    에이전트의 **tool/action**으로 노출할 수 있다.

- p25의 다이어그램에는:

  - Language Agent
  - AgentKit
  - WalletProviders
  - ActionProviders
  - CDP SDK
  - Base Blockchain
    등이 연결된 구조가 나타난다.

## 5.3 x402와 함께 사용하는 예시 (p26)

Python + Pydantic AI 예시의 구조:

```python
from coinbase_agentkit import (
    AgentKit,
    CdpEvmWalletProvider,
    cdp_api_action_provider,
    erc20_action_provider,
    pyth_action_provider,
    wallet_action_provider,
    weth_action_provider,
    x402_action_provider,  # <- 여기서 x402 기능을 추가
)
from coinbase_agentkit_pydantic_ai import get_pydantic_ai_tools
from pydantic_ai import Agent

async def initialize_agent(config: CdpEvmWalletProviderConfig):
    wallet_provider = CdpEvmWalletProvider(config)

    agentkit = AgentKit(
        AgentKitConfig(
            wallet_provider=wallet_provider,
            action_providers=[
                cdp_api_action_provider(),
                erc20_action_provider(),
                pyth_action_provider(),
                wallet_action_provider(),
                weth_action_provider(),
                x402_action_provider(),  # x402 결제 액션
            ],
        )
    )

    tools = get_pydantic_ai_tools(agentkit)

    agent = Agent(
        model="openai:gpt-5-mini",
        name="CDP Agent",
        system_prompt="system prompt",
        tools=tools,
    )
    return agent, wallet_provider
```

- 핵심 포인트:

  - AgentKit은 다양한 action provider를 묶어 **에이전트용 “tool 세트”**로 만들고,
  - `x402_action_provider()`를 포함하면,

    - 에이전트가 스스로 `x402` 결제/전송 기능을 호출할 수 있게 된다.

---

# 6. x402 Demo 아키텍처 (p27)

슬라이드는 3요소를 강조한다:

1. **x402 미들웨어가 탑재된 FastAPI 서버**

   - `/protected` 등 유료 엔드포인트를 제공.

2. **AgentKit 기반 x402 AI Agent**

   - 사용자의 의도(프롬프트)에 따라,
   - 필요할 때 x402 액션을 호출해 결제를 수행.

3. **Payment Required 엔드포인트 호출**

   - 에이전트가 이 엔드포인트를 호출하면:

     - 402 응답 → 결제 → 재요청 → 데이터 획득
       일련의 과정을 자동화해 수행.

즉, 전체 데모는:

> **“LLM 에이전트가 스스로 지갑을 사용해서 x402 결제로 FastAPI 유료 API에 접근하는”** 파이프라인이다.

---

# 7. 커뮤니티 정보 (p28)

- Based Korea 커뮤니티 채널 안내:

  - X(트위터): `@daehan_base`
  - 텔레그램:

    - 공지방: `@daehan_base`
    - 채팅방: `@daehanbase`
    - 개발자 그룹: `@daehan_base_devs`

---

# 8. 다른 LLM이 사용할 때 핵심 포인트 정리 (Bullet 형식, 영어 중심)

다른 LLM에 그대로 넣어도 좋은 핵심 요약을 별도로 정리:

1. **Base App + MiniApp**

   - Base App is Coinbase’s rebranded wallet app aiming to be a social + messaging + MiniApp super app on the Base L2 network.
   - MiniApps are lightweight web apps that run inside Base App or Farcaster, discoverable via search and social sharing, hosted on standard web infra (e.g., Vercel) and indexed via simple configuration.

2. **x402**

   - Open payment standard enabling autonomous agents and web services to pay for APIs, data, and digital services using on-chain stablecoins.
   - Leverages HTTP `402 Payment Required` responses to negotiate payments.
   - Core flow:

     1. Client sends an HTTP request.
     2. Server responds with HTTP 402 + x402 JSON payload (price, payTo, asset, network, etc.).
     3. Client/agent submits a second request including a signed EIP-3009 authorization/payment.
     4. Server or facilitator verifies/broadcasts the payment and returns the actual resource.

   - Benefits over legacy payments:

     - No accounts, no KYC, no manual subscription flows.
     - Near-instant settlement (~200ms) on L2 with negligible gas fees and no chargebacks.
     - Practical micro-payments down to fractions of a cent, enabling pay-per-request and usage-based billing for APIs, AI inference, on-demand content, and machine-to-machine interactions.

3. **x402 Server Integration**

   - Server-side libraries provide middleware (`require_payment`, `paymentMiddleware`) that turn endpoints into paid APIs with one line of configuration (price, receiver address, network, facilitator URL).
   - HTTP 402 responses carry structured payment metadata for agents.

4. **x402 Client Integration**

   - Client libraries (`x402HttpxClient` in Python, `wrapFetchWithPayment` in JS) wrap HTTP clients:

     - Detect 402 responses.
     - Orchestrate wallet signing and on-chain payment.
     - Retry the request and return the final result.

   - This abstracts away the payment negotiation from the agent’s high-level logic.

5. **AgentKit**

   - A chain/LLM/wallet-agnostic toolkit that gives AI agents blockchain wallets and on-/off-chain actions.
   - Defines:

     - `WalletProvider` for secure key management and transactions.
     - `ActionProvider`s (e.g., ERC-20, wallet operations, Pyth price feeds, Wrapped ETH, x402).

   - Action providers are exposed as tools to agent frameworks (e.g., Pydantic AI, LangChain).
   - Including `x402_action_provider` allows agents to autonomously perform x402 payments while interacting with paid APIs.

6. **End-to-End Demo**

   - A FastAPI server exposes a paid API endpoint using x402 middleware.
   - An AgentKit-based AI agent with x402 tools calls that endpoint:

     - Receives a 402.
     - Executes payment via its wallet.
     - Obtains the final response.

   - Demonstrates fully autonomous, wallet-enabled AI agents consuming paid services on Base.
